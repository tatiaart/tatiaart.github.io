<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" href="/markdown.css" type="text/css">
    <link rel="stylesheet" href="markdown.css" type="text/css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  </head>
  <body>
    <script>hljs.highlightAll();</script>
    
    
    
    <a href = "/Progress" title="/Progress">
      <div class="file_link">
        <img src = "/foldback.png" class="fileicon"width = 16px height = 16px>
        Back to tatiaart.github.io/Progress
      </div></a>
    <a href = /Progress/Pin_Definitions.zip title="Click to download" class="download_link">
      <div>
      <img src="/download.png" width = 32px height = 32px>
      <span>Download this package</span></div></a>
    <h1 id="gpio">GPIO</h1>
<p>The goal of this example is to showcase how GPIO pin functions can be defined through arduino code and through register configuration.</p>

<p><img src="example_schematic.png" alt="Circuit schematic" title="Schematic" /></p>

<h2 id="basic">Basic</h2>
<p>We can start with a basic arduino sketch.</p>

<p>We will need to configure PA_11 &amp; PA_12 to have internal pullup resistors to prevent the pins from floating when they are not connected to GND through the pushbutton.
In this configuration, the state of the pin will be inverse to the state of the button (pressed = 0, released = 1)</p>

<p><a href="./basic?hl=basic.ino&amp;return=basic/basic.ino" class="filename_outer" id="basic/basic.ino" title="Show basic.ino in package"><span class="filename_inner">./basic/basic.ino</span>
</a></p>

<pre><code class="language-C">void setup() {
  pinMode(PA_14, INPUT_PULLUP);
  pinMode(PA_13, INPUT_PULLUP);
  pinMode(PA_12, OUTPUT);
  pinMode(PA_11, OUTPUT);
}

void loop() {
  digitalWrite(PA_12, digitalRead(PA_14));
  digitalWrite(PA_11, digitalRead(PA_13));
}
</code></pre>

<p>The above example allows us to push the button to activate the board’s built-in LED.</p>

<h2 id="writing-and-reading-with-direct-register-access">Writing and reading with direct register access</h2>
<p>The reference manual of the MCU installed on the board provides all the info that is required for configuring/operating GPIO: <br />
<a href="https://www.st.com/resource/en/reference_manual/rm0444-stm32g0x1-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32G0x1 reference manual on st.com</a></p>

<p>The STM32 GPIO peripheral directly exposes the input and output data registers to the SW:</p>

<p><img src="idrandodr.png" alt="GPIOx_IDR and GPIOx_ODR register descriptions" /></p>

<p>Reading from the GPIOx_IDR register will give us the state of all the port’s inputs in a 32 bit unsigned integer (of which only the bottom 16 bits will have meaning, as the ports only have 16 pins).
Writing, in turn, to the GPIOx_ODR register will directly influence the pin’s output states (LOW = 0, HIGH = 1)</p>

<p>Importantly, reading and writing are operations done on a whole unsigned integer, meaning that the MCU executes them in a single instruction. This is more efficient than getting/setting the pins’ values one-by-one.</p>

<p>We want to put the values of GPIOx_IDR ID[13] and ID[14] into GPIOx_ODR OD[11] and OD[12] respectively. Let’s have a look at the manipulations required to do so:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">GPIOA-&gt;IDR &gt;&gt; 13</code> returns the value of the GPIOA_IDR register, bit-shifted to the right by 13, meaning that bits 0 and 1 of the value are bits 13 and 14 of the original register.</li>
  <li><code class="language-plaintext highlighter-rouge">(GPIOA-&gt;IDR &gt;&gt; 13) &amp; 0b11</code> isolates the lowest 2 bits of the value, leaving all other bits as 0 (this should not affect this example, but if you have other pins configured for other reasons, this is necessary to avoid modifying other pin states.)</li>
  <li><code class="language-plaintext highlighter-rouge">((GPIOA-&gt;IDR &gt;&gt; 13) &amp; 0b11) &lt;&lt; 11</code> shifts the value 11 bits to the left. The original bits 13 and 14 get moved to positions 0 and 1, and then back to 11 and 12. All other bits of this value are zero. This is what we will be writing to the GPIOA_ODR register.</li>
</ol>

<p><a href="./basic_odr_idr?hl=basic_odr_idr.ino&amp;return=basic_odr_idr/basic_odr_idr.ino" class="filename_outer" id="basic_odr_idr/basic_odr_idr.ino" title="Show basic_odr_idr.ino in package"><span class="filename_inner">./basic_odr_idr/basic_odr_idr.ino</span>
</a></p>

<pre><code class="language-C">void setup() {
  pinMode(PA_14, INPUT_PULLUP);
  pinMode(PA_13, INPUT_PULLUP);
  pinMode(PA_12, OUTPUT);
  pinMode(PA_11, OUTPUT);
}

void loop() {
  GPIO-&gt;ODR = (((GPIOA-&gt;IDR &gt;&gt; 13) &amp; 0b11) &lt;&lt; 11);
}
</code></pre>

<p>The same result is achieved as with the basic example - the button states are reflected on the output LED’s.</p>

<h2 id="efficiently-configuring-more-pins">Efficiently configuring more pins</h2>

<p>STM32duino’s <code class="language-plaintext highlighter-rouge">pinMode()</code> function does a few things:</p>
<ol>
  <li>Get the pin’s GPIO port X and pin number N (PX_N)</li>
  <li>Enable GPIO port X’s clock</li>
  <li>Set the GPIO port speed</li>
  <li>For certain MCU families, handle alternative pin functions</li>
  <li>Appropriately modify the port’s pin mode register</li>
  <li>Appropriately modify the port’s pullup register</li>
</ol>

<p>And does so every time the function is called.</p>

<p>However, things like enabling the port’s clock/setting it’s speed only have to be done once. 
So, if we wished to simplify compiled code, we could omit calling <code class="language-plaintext highlighter-rouge">pinMode()</code> and instead configure pins through their registers all at once.</p>

<p>Let’s look at the registers required to accomplish this:</p>

<p><img src="iopenr.png" alt="RCC_IOPENR register description" /></p>

<p><img src="moder.png" alt="GPIOx_MODER register description" /></p>

<p><img src="pupdr.png" alt="GPIOX_PUPDR register description" /></p>

<p>For our simple mode of operation, it is sufficient to:</p>
<ol>
  <li>Enable the GPIOA port clock (setting bit 0 of RCC_IOPENR)</li>
  <li>Configure GPIOA_MODER</li>
  <li>Configure GPIOA_PUPDR</li>
</ol>

<p>Let’s take a look at what value written to GPIOA_MODER will achieve the outlined configuration:</p>
<ul>
  <li>MODE[11] is 01 (OUTPUT)</li>
  <li>MODE[12] is 01 (OUTPUT)</li>
  <li>MODE[13] is 00 (INPUT)</li>
  <li>MODE[14] is 00 (INPUT)</li>
</ul>

<p>The rest of the bits aren’t important in this example and will be left at their reset values.
Since the register initializes to 0xFFFFFFFF (all ones), we just need to reset the necessary bits with a single write:
<code class="language-plaintext highlighter-rouge">GPIOA-&gt;MODER &amp;= ~(0b11111010 &lt;&lt; 2 * 11);</code></p>

<p><a href="./advanced?hl=advanced.ino&amp;return=advanced/advanced.ino" class="filename_outer" id="advanced/advanced.ino" title="Show advanced.ino in package"><span class="filename_inner">./advanced/advanced.ino</span>
</a></p>

<pre><code class="language-C">void setup() {
  // To configure pins PA_13 and PA_14 as inputs with pullup resistors, and PA_11 and PA_12 as outputs:
  // 1. No need to translate arduino to stm32 pins (we already know them - PORT_A, pins 11 - 14)

  // 2. Enable the GPIO port A clock
  RCC-&gt;IOPENR |= (1 &lt;&lt; 0);       // Set bit 0 of the RCC_IOPENR register, enabling port A clock.

  // 3. No need to set port speed since the default value is adequate.
  // 4. No need to handle alternative pin functions for this MCU

  // 5. Write the configuration registers
  GPIOA-&gt;MODER &amp;= ~(0b11111010 &lt;&lt; 2 * 11);  // Write the calculated configuration

  GPIOA-&gt;PUPDR &amp;= ~(0b1111 &lt;&lt; 2 * 13);      // Reset bits 26 - 29, and set bit 26 and 28 of the GPIOA_PUPDR register,
  GPIOA-&gt;PUPDR |=  (0b0101 &lt;&lt; 2 * 13);      // setting pin PA_13 and PA_14's internal pullup mode to 01 (pull-up) 
}

void loop() {
  GPIO-&gt;ODR = (((GPIOA-&gt;IDR &gt;&gt; 13) &amp; 0b11) &lt;&lt; 11);
}
</code></pre>

<p>The same result is achieved as the original code, except every port access relates to multiple pins at once, which in this simple example potentially doubles execution speed.</p>

<p>And so, without using any costly Arduino functions, we can now manipulate GPIO pins through direct register access.</p>


    <script>
      function getQueryVariable(variable) {
          var query = window.location.search.substring(1);
          var vars = query.split("&");
          for (var i = 0; i < vars.length; i++) {
              var pair = vars[i].split("=");
              if (pair[0] == variable) {
                  return pair[1];
              }
          }
          return (false);
      }
  
      if (getQueryVariable("hl") != false) {
          var pid = getQueryVariable("hl");
          var url = window.location.protocol + "//" + window.location.host + window.location.pathname;
          var newurl = url.split("?")[0];
          window.history.replaceState({path:newurl},'',newurl);
          document.getElementById(""+pid).scrollIntoView({ behavior: "smooth", block: "center", inline:"center"});
      }
      </script>
  </body>
</html>